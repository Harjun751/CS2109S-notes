<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="generator" content="MarkBind 6.2.0">
    <meta name="viewport" content="width=device-width, initial-scale=1"><title>Search | Week 2</title> <link rel="stylesheet" href="/CS2109S-notes/markbind/css/bootstrap.min.css"> <link rel="stylesheet" href="/CS2109S-notes/markbind/fontawesome/css/all.min.css"> <link rel="stylesheet" href="/CS2109S-notes/markbind/glyphicons/css/bootstrap-glyphicons.min.css"><link rel="stylesheet" href="/CS2109S-notes/markbind/css/codeblock-dark.min.css"><link rel="stylesheet" href="/CS2109S-notes/markbind/css/markbind.min.css"><link rel="stylesheet" href="/CS2109S-notes/plugins/markbind-plugin-anchors/markbind-plugin-anchors.css"><link rel="stylesheet" href="/CS2109S-notes/plugins/markbind-plugin-tree/markbind-plugin-tree.css">
    
  <link rel="stylesheet" href="/CS2109S-notes/stylesheets/main.css">
</head>
<script>
  const baseUrl = '/CS2109S-notes'
</script>
<body  data-bs-spy="scroll" data-bs-target="#mb-page-nav" data-bs-offset="100"  data-code-theme="dark">
<div id="app"><!--[--><header sticky><div data-v-26aac3dc><nav class="navbar navbar-expand-md d-print-none navbar-dark bg-dark" data-v-26aac3dc><div class="container-fluid" data-v-26aac3dc><div class="navbar-left" data-v-26aac3dc><!--[--><!--]--></div><div class="navbar-default" data-v-26aac3dc><ul class="navbar-nav me-auto mt-2 mt-lg-0" data-v-26aac3dc><!--[--><!--]--></ul></div><ul class="navbar-nav navbar-right" data-v-26aac3dc><!--[--><li><form class="navbar-form"><div style="position:relative;" class="dropdown" data-v-00e26d0a><!--[--><input value="" data-bs-toggle="dropdown" type="text" class="form-control" placeholder="Search" autocomplete="off" data-v-00e26d0a><div class="form-control placeholder-div-hidden" data-v-00e26d0a>Search</div><!--]--><ul class="dropdown-menu search-dropdown-menu dropdown-menu-hidden dropdown-menu-end" data-v-00e26d0a><!--[--><!--]--></ul></div></form></li><!--]--></ul></div></nav><div style="display:none;" class="lower-navbar-container" data-v-26aac3dc><!--[--><!----><!----><!--]--></div></div></header> <div id="flex-body"><nav id="site-nav" data-v-6b1b63d2><!--[--><div class="site-nav-top"><div class="fw-bold mb-2" style="font-size:1.25rem;">Contents</div></div> <div class="nav-component slim-scroll"><div class="site-nav-root"><!--[--><ul class="site-nav-list site-nav-list-root" data-v-6b1b63d2><!--[--><li><div class="site-nav-default-list-item site-nav-list-item-0" onclick="handleSiteNavClick(this)"><a href="/CS2109S-notes/index.html">Home</a></div></li> <li><div class="site-nav-default-list-item site-nav-list-item-0" onclick="handleSiteNavClick(this)"><a href="/CS2109S-notes/contents/week2.html">Search</a></div></li> <li><div class="site-nav-default-list-item site-nav-list-item-0" onclick="handleSiteNavClick(this)"><a href="/CS2109S-notes/contents/week3.html">Adversarial Search</a></div></li> <li><div class="site-nav-default-list-item site-nav-list-item-0" onclick="handleSiteNavClick(this)"><a href="/CS2109S-notes/contents/week4.html">Machine Learning &amp; Decision Trees</a></div></li> <li><div class="site-nav-default-list-item site-nav-list-item-0" onclick="handleSiteNavClick(this)"><a href="/CS2109S-notes/contents/week5.html">Linear Regression</a></div></li> <li><div class="site-nav-default-list-item site-nav-list-item-0" onclick="handleSiteNavClick(this)"><a href="/contents/week6.html">Logistic Regression</a></div></li><!--]--><!--v-if--></ul><!--]--></div></div><!--]--><!--v-if--></nav> <div id="content-wrapper"><h1 id="search">Search<a class="fa fa-anchor" href="#search" onclick="event.stopPropagation()"></a></h1> <p>A search problem refers to a type of problem where the goal is to find a state or a path to a state from a set of possible states by exploring various possibilities. It either returns a possible solution, or a failure indication. Often, we talk about the <em>optimal</em> solution - the path that is the shortest.</p> <h2 id="designing-an-agent-to-do-search">Designing an agent to do search<a class="fa fa-anchor" href="#designing-an-agent-to-do-search" onclick="event.stopPropagation()"></a></h2> <div id="formulation">
When designing a search agent, we should go through *problem formulation*.
<p>We decide on:</p> <ol><li><p>State</p></li> <li><p>Initial State</p></li> <li><p>Goal State</p></li> <li><p>Actions</p></li> <li><p>Transition model</p></li> <li><p>Action Cost</p></li></ol></div> <div class="card-container" data-v-4484e25a><div class="card expandable-card" data-v-4484e25a><div class="card-header header-toggle bg-light" data-v-4484e25a><div class="caret-wrapper" data-v-4484e25a><!----></div><div class="header-wrapper card-title bg-light" data-v-4484e25a><!--[--><!--[--><p>Romania Problem Formulation</p><!--]--><!--]--></div><div class="button-wrapper" data-v-4484e25a><!--[--><button type="button" class="collapse-button btn btn-outline-secondary" style="" data-v-4484e25a><span class="collapse-icon glyphicon glyphicon-menu-down" aria-hidden="true"></span></button><button style="" type="button" class="btn-outline-secondary close-button btn" data-v-4484e25a><span class="glyphicon glyphicon-remove" aria-hidden="true" data-v-4484e25a></span></button><button style="display:none;" type="button" class="btn-outline-secondary popup-button btn" data-v-4484e25a><span class="glyphicon glyphicon-new-window" aria-hidden="true" data-v-4484e25a></span></button><!--]--></div></div><div class="card-collapse" data-v-4484e25a><!----><hr style="display:none;" data-v-4484e25a></div><!----></div></div> <h2 id="search-pseudocode">Search pseudocode<a class="fa fa-anchor" href="#search-pseudocode" onclick="event.stopPropagation()"></a></h2> <pre><code class="hljs"><span>create frontier             # queue, pque, stack
</span><span>
</span><span>insert node(initial state) to frontiner
</span><span>while frontiner is not empty:
</span><span>    node = frontier.pop()
</span><span>    if node.state is goal: return solution
</span><span>
</span><span>    for action in actions(node.state):
</span><span>        next_state = transition(node.state, action);
</span><span>        frontier.add(Node(next_state))
</span><span>return failure
</span></code></pre><h2 id="terminology">Terminology<a class="fa fa-anchor" href="#terminology" onclick="event.stopPropagation()"></a></h2> <p>Problem (graph)
Search tree - the DS made by the search
Node (in search tree) -<span class="small">contains</span>&gt; States (in node)</p> <h2 id="evaluation-criteria">Evaluation criteria<a class="fa fa-anchor" href="#evaluation-criteria" onclick="event.stopPropagation()"></a></h2> <p>Time complexity - Number of nodes generated/expanded
Space complexity - maximum number of nodes in memory</p> <h3 id="completeness">Completeness<a class="fa fa-anchor" href="#completeness" onclick="event.stopPropagation()"></a></h3> <p>An algorithm is complete if for every problem instance, it will find a solution if one exists.</p> <h3 id="optimal">Optimal<a class="fa fa-anchor" href="#optimal" onclick="event.stopPropagation()"></a></h3> <p>Algo is optimal if the solution produced is guaranteed to be optiomal</p> <p>Optimal &amp; Incomplete algorithms exist.</p> <h1 id="uninformed-search-algorithms">Uninformed Search algorithms<a class="fa fa-anchor" href="#uninformed-search-algorithms" onclick="event.stopPropagation()"></a></h1> <p>Has no idea how &quot;good&quot; a state is - we don&#39;t know how close a state is to the goal.
Only know problem formulation and action cost.</p> <h2 id="bfs">BFS<a class="fa fa-anchor" href="#bfs" onclick="event.stopPropagation()"></a></h2> <p>BFS - apply a queue to the search pseudocode and we got it!</p> <p>Time Complexity - Exponentional
Space Complexity - Exponential
Completeness - If a problem has a finite branching factor, and there exists a goal at a finite depth, BFS is complete; it will terminate and return a solution
Optimality: Assume all actions have equal positive cost. If a goal exists at a finite depth, BFS returns a solution with minimal path cost.</p> <h2 id="uniform-cost-search-ucs">Uniform Cost Search (UCS)<a class="fa fa-anchor" href="#uniform-cost-search-ucs" onclick="event.stopPropagation()"></a></h2> <p>UCS - apply a priority queue</p> <p>Time complexity - Exponential
Space - Exponential</p> <p>Completeness - Finite branching factor, and every action cost must be positive and non zero. Then, if optimal path cost is &lt; inf, then UCS is complete</p> <p>Optimality - Positive edge cost implies optimality.</p> <h2 id="dfs">DFS<a class="fa fa-anchor" href="#dfs" onclick="event.stopPropagation()"></a></h2> <p>DFS - Apply a stack</p> <p>Time complexity - Exponential
Space - Polynomial (only need to keep track of one path - the max depth)</p> <p>Complete - Not complete. When DFS is infinite
Optimal - No, the optimal solution may be in a shallower depth.</p> <h2 id="search-with-visited-memory">Search With visited memory<a class="fa fa-anchor" href="#search-with-visited-memory" onclick="event.stopPropagation()"></a></h2> <p>Add a visited DS - then check if node has been visited before traversing further.</p> <h1 id="informed-search-algorithms">Informed Search Algorithms<a class="fa fa-anchor" href="#informed-search-algorithms" onclick="event.stopPropagation()"></a></h1> <p>&quot;Search with extra info&quot;</p> <h2 id="heuristic">Heuristic<a class="fa fa-anchor" href="#heuristic" onclick="event.stopPropagation()"></a></h2> <p>Recall:</p> <ul><li>Path cost is the cost of a path from any state to any state.</li> <li>Optimal path cost is the lowest-cost path</li></ul> <p>A Heuristic is an estimate of the optimal path cost from any state to the goal state.
All heuristic functions must be non-negative and have h(goal) = 0</p> <h2 id="best-first-search">Best-first search<a class="fa fa-anchor" href="#best-first-search" onclick="event.stopPropagation()"></a></h2> <p>Create a priority queue where f(n) = h(n)</p> <h2 id="a-search">A* Search<a class="fa fa-anchor" href="#a-search" onclick="event.stopPropagation()"></a></h2> <p>Create a priority queue where f(n) = g(n) + h(n)
g(n) represents the cost to reach n, and h(n) represents the cost to reach the goal from n.</p> <p>Time complexity: Exponential
Space: Exponential</p> <p>Completeness: Similar to UCS, but additional conditions for heuristic
Optimality: Similar to UCS, but additional conditions for heuristic</p> <h3 id="admissable-heuristics">Admissable Heuristics<a class="fa fa-anchor" href="#admissable-heuristics" onclick="event.stopPropagation()"></a></h3> <p>A heuristic h(N) is admissible if for every node n, 0 &lt;= h(n) &lt;= h*(n), where h*(n) is the optimal path cost to reach the goal state from n.
I.e., it never overestimates the actual true cost.</p> <p>If admissible, A* search without visited memory is complete and optimal (with the UCS constraint)</p> <h4 id="inventing-admissable-heuristic">Inventing Admissable Heuristic<a class="fa fa-anchor" href="#inventing-admissable-heuristic" onclick="event.stopPropagation()"></a></h4> <p>A problem with fewer restrictions on the actions is called a relaxed problem.</p> <p>The cost of an optimal solution to a relaxed problem is an admissible heuristic for the original problem.</p> <h4 id="dominance">Dominance<a class="fa fa-anchor" href="#dominance" onclick="event.stopPropagation()"></a></h4> <p>if h1(n) &gt;= h2(n), then h1 dominates h2.
If admissible, then h1 is better for search (since it&#39;s a better estimate)</p> <h3 id="consistent-heuristics">Consistent Heuristics<a class="fa fa-anchor" href="#consistent-heuristics" onclick="event.stopPropagation()"></a></h3> <p>A h(n) is consistent if for every node n, every successor n&#39; of n, h(n) &lt;= c(n,a,n&#39;) + h(n&#39;)
Triangle inequality</p> <p>Theorem - if h(n) is consistent, A* search with visited memory is complete and optimal (with the UCS constraint)</p> <p>Consistentcy =&gt; Admissability.</p> <h2 id="search-strategies">Search Strategies<a class="fa fa-anchor" href="#search-strategies" onclick="event.stopPropagation()"></a></h2> <p>Without visited memory, search algorithms may not terminate.</p> <ul><li>Depth-first search uses polynomial memory but may not terminate.</li> <li>Strategy: Set a strict resource limit. One example is max depth</li> <li>This gives birth to a search with polynomial memory, but is complete and optimal</li></ul> <h3 id="depth-limited-search">Depth-limited search<a class="fa fa-anchor" href="#depth-limited-search" onclick="event.stopPropagation()"></a></h3> <p>Limited depth to l
Backtrack when limit is hit.</p> <p>Time complexity: Exponential
Space: Polynomial
Completeness: No
Optimal: No, if used with DFS.</p> <h3 id="iterative-deepening-search">Iterative Deepening search<a class="fa fa-anchor" href="#iterative-deepening-search" onclick="event.stopPropagation()"></a></h3> <p>Time complexity: Exponential (with overhead)
Space: Polynomial
Complete: Yes, under the same conditions that guarantee BFS completeness
Optimal: Yes, under the same conditions that guarantee BFS optimality.</p></div> <nav id="page-nav" data-v-6b1b63d2><!--[--><div class="nav-component slim-scroll"><a class="navbar-brand page-nav-title" href="#">Topics</a> <nav id="mb-page-nav" class="nav nav-pills flex-column my-0 small no-flex-wrap" data-v-6b1b63d2><!--[--><a class="nav-link py-1" href="#search">Search‎</a> <nav class="nav nav-pills flex-column my-0 nested no-flex-wrap"><a class="nav-link py-1" href="#designing-an-agent-to-do-search">Designing an agent to do search‎</a> <a class="nav-link py-1" href="#search-pseudocode">Search pseudocode‎</a> <a class="nav-link py-1" href="#terminology">Terminology‎</a> <a class="nav-link py-1" href="#evaluation-criteria">Evaluation criteria‎</a> <nav class="nav nav-pills flex-column my-0 nested no-flex-wrap"><a class="nav-link py-1" href="#completeness">Completeness‎</a> <a class="nav-link py-1" href="#optimal">Optimal‎</a></nav></nav> <a class="nav-link py-1" href="#uninformed-search-algorithms">Uninformed Search algorithms‎</a> <nav class="nav nav-pills flex-column my-0 nested no-flex-wrap"><a class="nav-link py-1" href="#bfs">BFS‎</a> <a class="nav-link py-1" href="#uniform-cost-search-ucs">Uniform Cost Search (UCS)‎</a> <a class="nav-link py-1" href="#dfs">DFS‎</a> <a class="nav-link py-1" href="#search-with-visited-memory">Search With visited memory‎</a></nav> <a class="nav-link py-1" href="#informed-search-algorithms">Informed Search Algorithms‎</a> <nav class="nav nav-pills flex-column my-0 nested no-flex-wrap"><a class="nav-link py-1" href="#heuristic">Heuristic‎</a> <a class="nav-link py-1" href="#best-first-search">Best-first search‎</a> <a class="nav-link py-1" href="#a-search">A* Search‎</a> <nav class="nav nav-pills flex-column my-0 nested no-flex-wrap"><a class="nav-link py-1" href="#admissable-heuristics">Admissable Heuristics‎</a> <nav class="nav nav-pills flex-column my-0 nested no-flex-wrap"><a class="nav-link py-1" href="#inventing-admissable-heuristic">Inventing Admissable Heuristic‎</a> <a class="nav-link py-1" href="#dominance">Dominance‎</a></nav> <a class="nav-link py-1" href="#consistent-heuristics">Consistent Heuristics‎</a></nav> <a class="nav-link py-1" href="#search-strategies">Search Strategies‎</a> <nav class="nav nav-pills flex-column my-0 nested no-flex-wrap"><a class="nav-link py-1" href="#depth-limited-search">Depth-limited search‎</a> <a class="nav-link py-1" href="#iterative-deepening-search">Iterative Deepening search‎</a></nav></nav><!--]--><!--v-if--></nav></div><!--]--><!--v-if--></nav> <div class="scroll-top-button fa-lg d-print-none" style="display:none;bottom:2%;right:2%;position:fixed;" aria-hidden="true"><!--[--><i class="fas fa-arrow-circle-up"></i><!--]--></div></div> <footer><div class="text-center"><small>[Generated by <a href="https://markbind.org/">MarkBind 6.2.0</a>]</small></div></footer><!--]--></div>
</body><script src="/CS2109S-notes/markbind/js/bootstrap-utility.min.js"></script>
<script src="/CS2109S-notes/markbind/js/polyfill.min.js"></script>
<script src="/CS2109S-notes/markbind/js/vue.global.prod.min.js"></script>
<script src="/CS2109S-notes/markbind/js/markbind.min.js"></script>
<script src="week2.page-vue-render.js"></script>
<script>
  MarkBind.setupWithSearch()
</script>
</html>
